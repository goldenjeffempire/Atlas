var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  activityLogs: () => activityLogs,
  activityLogsRelations: () => activityLogsRelations,
  analytics: () => analytics,
  bookings: () => bookings,
  bookingsRelations: () => bookingsRelations,
  insertBookingSchema: () => insertBookingSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertUserSchema: () => insertUserSchema,
  insertWorkspaceSchema: () => insertWorkspaceSchema,
  locations: () => locations,
  notifications: () => notifications,
  notificationsRelations: () => notificationsRelations,
  organizations: () => organizations,
  registerUserSchema: () => registerUserSchema,
  users: () => users,
  usersRelations: () => usersRelations,
  workspaces: () => workspaces,
  workspacesRelations: () => workspacesRelations
});
import { pgTable, text, serial, integer, timestamp, boolean, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: text("email").notNull().unique(),
  password: text("password").notNull(),
  companyName: text("company_name").notNull(),
  role: text("role", { enum: ["admin", "general", "employee", "learner"] }).notNull().default("general"),
  // Admin fields
  adminTitle: text("admin_title"),
  adminDepartment: text("admin_department"),
  // General user fields
  jobTitle: text("job_title"),
  // Employee fields
  employeeId: text("employee_id"),
  department: text("department"),
  // Common fields
  phoneNumber: text("phone_number"),
  avatarUrl: text("avatar_url"),
  preferences: jsonb("preferences"),
  // Stripe fields for payment integration
  stripeCustomerId: text("stripe_customer_id"),
  // Google Calendar integration
  googleCalendarToken: text("google_calendar_token"),
  // Account status
  isActive: boolean("is_active").notNull().default(true),
  lastLogin: timestamp("last_login"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  lastLogin: true,
  stripeCustomerId: true,
  googleCalendarToken: true,
  avatarUrl: true,
  preferences: true,
  isActive: true
});
var workspaces = pgTable("workspaces", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  location: text("location").notNull(),
  type: text("type", { enum: ["desk", "meeting_room", "collaborative_space", "private_office", "focus_pod", "virtual_conference", "phone_booth"] }).notNull(),
  imageUrl: text("image_url").notNull(),
  features: jsonb("features").notNull(),
  capacity: integer("capacity").notNull().default(1),
  floorPlan: text("floor_plan"),
  description: text("description"),
  hourlyRate: integer("hourly_rate"),
  // In cents for Stripe integration
  availability: jsonb("availability"),
  // Operating hours or special availability rules
  isActive: boolean("is_active").notNull().default(true),
  // QR code for check-in
  checkInCode: text("check_in_code"),
  // Integration IDs
  openingTime: text("opening_time").default("09:00"),
  closingTime: text("closing_time").default("17:00"),
  zoomRoomId: text("zoom_room_id"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertWorkspaceSchema = createInsertSchema(workspaces).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  isActive: true,
  checkInCode: true,
  zoomRoomId: true
});
var bookings = pgTable("bookings", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  workspaceId: integer("workspace_id").notNull().references(() => workspaces.id),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  status: text("status", { enum: ["pending", "confirmed", "cancelled", "checked_in", "completed"] }).notNull().default("pending"),
  title: text("title"),
  description: text("description"),
  participants: jsonb("participants"),
  // Additional participants
  // Payment related fields
  paymentStatus: text("payment_status", { enum: ["unpaid", "paid", "refunded"] }),
  paymentId: text("payment_id"),
  // Stripe payment ID
  amount: integer("amount"),
  // Amount in cents
  // Calendar integration
  googleCalendarEventId: text("google_calendar_event_id"),
  // Check-in/check-out times
  checkInTime: timestamp("check_in_time"),
  checkOutTime: timestamp("check_out_time"),
  // For recurrences
  recurringBookingId: integer("recurring_booking_id"),
  recurringPattern: text("recurring_pattern"),
  // e.g., "weekly", "daily"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertBookingSchema = createInsertSchema(bookings).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  checkInTime: true,
  checkOutTime: true,
  googleCalendarEventId: true,
  paymentId: true,
  recurringBookingId: true
});
var organizations = pgTable("organizations", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  slug: text("slug").notNull().unique(),
  logoUrl: text("logo_url"),
  primaryColor: text("primary_color"),
  brandingSettings: jsonb("branding_settings"),
  policies: jsonb("policies"),
  features: jsonb("features"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var locations = pgTable("locations", {
  id: serial("id").primaryKey(),
  organizationId: integer("organization_id").references(() => organizations.id),
  name: text("name").notNull(),
  type: text("type", { enum: ["city", "building", "floor", "campus", "region"] }).notNull(),
  parentLocationId: integer("parent_location_id").references(() => locations.id),
  address: text("address"),
  coordinates: jsonb("coordinates"),
  // For map integration
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var registerUserSchema = insertUserSchema.extend({
  confirmPassword: z.string().min(6),
  // Make these fields optional since they depend on role
  phoneNumber: z.string().optional(),
  // Admin fields
  adminTitle: z.string().optional(),
  adminDepartment: z.string().optional(),
  // General fields
  jobTitle: z.string().optional(),
  // Employee fields
  employeeId: z.string().optional(),
  department: z.string().optional()
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});
var notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  type: text("type", { enum: ["booking_confirmation", "booking_reminder", "booking_cancellation", "admin_message", "system_alert"] }).notNull(),
  title: text("title").notNull(),
  message: text("message").notNull(),
  isRead: boolean("is_read").notNull().default(false),
  relatedBookingId: integer("related_booking_id").references(() => bookings.id),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var insertNotificationSchema = createInsertSchema(notifications).omit({
  id: true,
  createdAt: true
});
var analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  metricDate: timestamp("metric_date").notNull(),
  metricType: text("metric_type", { enum: ["daily_bookings", "workspace_utilization", "user_activity", "revenue"] }).notNull(),
  metricValue: jsonb("metric_value").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var activityLogs = pgTable("activity_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  action: text("action").notNull(),
  entityType: text("entity_type", { enum: ["user", "workspace", "booking", "system"] }).notNull(),
  entityId: integer("entity_id"),
  details: jsonb("details"),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var usersRelations = relations(users, ({ many }) => ({
  bookings: many(bookings),
  notifications: many(notifications),
  activityLogs: many(activityLogs)
}));
var workspacesRelations = relations(workspaces, ({ many }) => ({
  bookings: many(bookings)
}));
var bookingsRelations = relations(bookings, ({ one, many }) => ({
  user: one(users, {
    fields: [bookings.userId],
    references: [users.id]
  }),
  workspace: one(workspaces, {
    fields: [bookings.workspaceId],
    references: [workspaces.id]
  }),
  notifications: many(notifications)
}));
var notificationsRelations = relations(notifications, ({ one }) => ({
  user: one(users, {
    fields: [notifications.userId],
    references: [users.id]
  }),
  booking: one(bookings, {
    fields: [notifications.relatedBookingId],
    references: [bookings.id]
  })
}));
var activityLogsRelations = relations(activityLogs, ({ one }) => ({
  user: one(users, {
    fields: [activityLogs.userId],
    references: [users.id]
  })
}));

// server/storage.ts
import session from "express-session";
import connectPg from "connect-pg-simple";

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
neonConfig.webSocketConstructor = ws;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var pool = new Pool({ connectionString: process.env.DATABASE_URL });
var db = drizzle(pool, { schema: schema_exports });

// server/storage.ts
import { eq, and, ne, desc, count } from "drizzle-orm";
var PostgresSessionStore = connectPg(session);
var workspaceImages = [
  "https://images.unsplash.com/photo-1497366754035-f200968a6e72?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80",
  "https://images.unsplash.com/photo-1498050108023-c5249f4df085?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1600508773759-be507abb2bee?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1497215728101-856f4ea42174?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1540821924489-7690c70c4eac?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1524758631624-e2822e304c36?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1497366811353-6870744d04b2?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1416339698991-a20922e59443?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1520881363902-a0ff4e722963?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80",
  "https://images.unsplash.com/photo-1577412647305-991150c7d163?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80"
];
var DatabaseStorage = class {
  sessionStore;
  constructor() {
    this.sessionStore = new PostgresSessionStore({
      pool,
      createTableIfMissing: true,
      tableName: "session"
    });
    this.initializeSampleData();
  }
  async initializeSampleData() {
    try {
      const existingWorkspaces = await this.getWorkspaces();
      const adminUser = await this.getUserByEmail("admin@atlas.com");
      if (!adminUser) {
        const salt = randomBytes(16).toString("hex");
        const hashedPassword = await scryptAsync("admin123", salt, 64);
        const adminHashedPassword = `${hashedPassword.toString("hex")}.${salt}`;
        await this.createUser({
          email: "admin@atlas.app",
          password: adminHashedPassword,
          name: "System Administrator",
          companyName: "ATLAS Admin",
          role: "admin",
          adminTitle: "System Administrator",
          adminDepartment: "IT Operations",
          isActive: true,
          verified: true
        });
        await this.createUser({
          email: "employee@atlas.com",
          password: hashedPassword,
          companyName: "ATLAS Corp",
          role: "employee",
          employeeId: "EMP001",
          department: "Engineering"
        });
        await this.createUser({
          email: "user@atlas.com",
          password: hashedPassword,
          companyName: "ATLAS User",
          role: "general",
          jobTitle: "Contractor"
        });
      }
      if (existingWorkspaces.length === 0) {
        const workspaceTypes = ["desk", "meeting_room", "collaborative_space", "private_office", "focus_pod"];
        const locations2 = ["North Wing, Floor 4", "East Wing, Floor 2", "West Wing, Floor 3", "South Wing, Floor 1", "East Wing, Floor 5"];
        const names = [
          "Executive Desk",
          "Conference Room",
          "Collaborative Space",
          "Private Office",
          "Focus Pod",
          "Standing Desk",
          "Premium Desk",
          "Meeting Room",
          "Team Space",
          "Quiet Zone"
        ];
        const featuresList = [
          ["Adjustable Height", "Power Outlets", "Quiet Zone"],
          ["Video Conference", "Projector", "Seats 12"],
          ["Team Space", "Whiteboard", "Lounge Area"],
          ["Sound-proof", "Dedicated Phone", "Premium Desk"],
          ["Privacy Glass", "Noise Cancelling", "Compact"],
          ["Ergonomic", "USB-C Power", "Natural Light"],
          ["Adjustable Height", "Window View", "Ergonomic Chair"],
          ["Video Conference", "Whiteboard", "Seats 8"],
          ["Team Space", "Projector", "Standing Desks"],
          ["Window View", "Power Outlets", "Quiet Zone"]
        ];
        for (let i = 0; i < 10; i++) {
          const typeIndex = i % workspaceTypes.length;
          const type = workspaceTypes[typeIndex];
          const capacity = type === "desk" || type === "focus_pod" ? 1 : type === "private_office" ? 4 : type === "collaborative_space" ? 8 : 12;
          await this.createWorkspace({
            name: `${names[i]} ${String.fromCharCode(65 + i)}${Math.floor(Math.random() * 30)}`,
            location: locations2[i % locations2.length],
            type,
            imageUrl: workspaceImages[i % workspaceImages.length],
            features: featuresList[i % featuresList.length],
            capacity
          });
        }
      }
    } catch (error) {
      console.error("Failed to initialize sample data", error);
    }
  }
  // User methods
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByEmail(email) {
    const [user] = await db.select().from(users).where(eq(users.email, email.toLowerCase()));
    return user;
  }
  async createUser(userData) {
    const lowerCaseEmail = {
      ...userData,
      email: userData.email.toLowerCase()
    };
    const [newUser] = await db.insert(users).values(lowerCaseEmail).returning();
    return newUser;
  }
  // Workspace methods
  async getWorkspaces() {
    return db.select().from(workspaces);
  }
  async getWorkspace(id) {
    const [workspace] = await db.select().from(workspaces).where(eq(workspaces.id, id));
    return workspace;
  }
  async createWorkspace(workspaceData) {
    const [newWorkspace] = await db.insert(workspaces).values(workspaceData).returning();
    return newWorkspace;
  }
  // Booking methods
  async getAllBookings() {
    return db.select().from(bookings);
  }
  async getUserBookings(userId) {
    return db.select().from(bookings).where(eq(bookings.userId, userId));
  }
  async getBooking(id) {
    const [booking] = await db.select().from(bookings).where(eq(bookings.id, id));
    return booking;
  }
  async createBooking(bookingData) {
    const [newBooking] = await db.insert(bookings).values(bookingData).returning();
    return newBooking;
  }
  async updateBooking(id, bookingUpdate) {
    const [updatedBooking] = await db.update(bookings).set(bookingUpdate).where(eq(bookings.id, id)).returning();
    if (!updatedBooking) {
      throw new Error("Booking not found");
    }
    return updatedBooking;
  }
  async deleteBooking(id) {
    await db.delete(bookings).where(eq(bookings.id, id));
  }
  async checkWorkspaceAvailability(workspaceId, startTime, endTime, excludeBookingId) {
    let query = db.select().from(bookings).where(
      and(
        eq(bookings.workspaceId, workspaceId),
        ne(bookings.status, "cancelled")
      )
    );
    if (excludeBookingId) {
      query = db.select().from(bookings).where(
        and(
          eq(bookings.workspaceId, workspaceId),
          ne(bookings.status, "cancelled"),
          ne(bookings.id, excludeBookingId)
        )
      );
    }
    const workspaceBookings = await query;
    const overlappingBookings = workspaceBookings.filter((booking) => {
      const bookingStart = new Date(booking.startTime);
      const bookingEnd = new Date(booking.endTime);
      return startTime >= bookingStart && startTime < bookingEnd || // Start time is within existing booking
      endTime > bookingStart && endTime <= bookingEnd || // End time is within existing booking
      startTime <= bookingStart && endTime >= bookingEnd;
    });
    return overlappingBookings.length === 0;
  }
  // Notification methods
  async getUserNotifications(userId, options = {}) {
    try {
      let query = db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));
      if (options.unreadOnly) {
        query = query.where(eq(notifications.isRead, false));
      }
      if (options.limit) {
        query = query.limit(options.limit);
      }
      return await query;
    } catch (error) {
      console.error("Error getting user notifications:", error);
      throw error;
    }
  }
  async getUnreadNotificationsCount(userId) {
    try {
      const result = await db.select({ count: count() }).from(notifications).where(and(
        eq(notifications.userId, userId),
        eq(notifications.isRead, false)
      ));
      return result[0]?.count || 0;
    } catch (error) {
      console.error("Error counting unread notifications:", error);
      throw error;
    }
  }
  async getNotification(id) {
    try {
      const [notification] = await db.select().from(notifications).where(eq(notifications.id, id));
      return notification;
    } catch (error) {
      console.error("Error getting notification:", error);
      throw error;
    }
  }
  async createNotification(data) {
    try {
      const [notification] = await db.insert(notifications).values({
        ...data,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return notification;
    } catch (error) {
      console.error("Error creating notification:", error);
      throw error;
    }
  }
  async markNotificationAsRead(id) {
    try {
      const [updatedNotification] = await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id)).returning();
      if (!updatedNotification) {
        throw new Error("Notification not found");
      }
      return updatedNotification;
    } catch (error) {
      console.error("Error marking notification as read:", error);
      throw error;
    }
  }
  async markAllNotificationsAsRead(userId) {
    try {
      const result = await db.update(notifications).set({ isRead: true }).where(and(
        eq(notifications.userId, userId),
        eq(notifications.isRead, false)
      ));
      return result.rowCount || 0;
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      throw error;
    }
  }
  async deleteNotification(id) {
    try {
      await db.delete(notifications).where(eq(notifications.id, id));
    } catch (error) {
      console.error("Error deleting notification:", error);
      throw error;
    }
  }
  async deleteAllUserNotifications(userId) {
    try {
      const result = await db.delete(notifications).where(eq(notifications.userId, userId));
      return result.rowCount || 0;
    } catch (error) {
      console.error("Error deleting all user notifications:", error);
      throw error;
    }
  }
  async deleteReadNotifications(userId) {
    try {
      const result = await db.delete(notifications).where(and(
        eq(notifications.userId, userId),
        eq(notifications.isRead, true)
      ));
      return result.rowCount || 0;
    } catch (error) {
      console.error("Error deleting read notifications:", error);
      throw error;
    }
  }
  // Analytics
  async getAnalytics() {
    const allWorkspaces = await this.getWorkspaces();
    const allBookings = await this.getAllBookings();
    const allUsers = await db.select().from(users);
    const now = /* @__PURE__ */ new Date();
    const activeBookings = allBookings.filter(
      (b) => b.status === "confirmed" && new Date(b.endTime) >= now
    );
    const bookingsByType = {};
    const workspaceTypesMap = new Map(
      allWorkspaces.map((workspace) => [workspace.id, workspace.type])
    );
    for (const booking of activeBookings) {
      const workspaceType = workspaceTypesMap.get(booking.workspaceId);
      if (workspaceType) {
        bookingsByType[workspaceType] = (bookingsByType[workspaceType] || 0) + 1;
      }
    }
    const bookingsCountByWorkspace = allBookings.reduce((counts, booking) => {
      if (booking.status !== "cancelled") {
        counts[booking.workspaceId] = (counts[booking.workspaceId] || 0) + 1;
      }
      return counts;
    }, {});
    const workspaceIdsSorted = Object.entries(bookingsCountByWorkspace).sort(([, countA], [, countB]) => countB - countA).slice(0, 5).map(([id]) => parseInt(id));
    const popularWorkspaces = allWorkspaces.filter((workspace) => workspaceIdsSorted.includes(workspace.id)).map((workspace) => ({
      workspace,
      bookingsCount: bookingsCountByWorkspace[workspace.id]
    })).sort((a, b) => b.bookingsCount - a.bookingsCount);
    return {
      totalWorkspaces: allWorkspaces.length,
      totalBookings: allBookings.length,
      activeBookings: activeBookings.length,
      bookingsByType,
      popularWorkspaces,
      totalUsers: allUsers.length
    };
  }
};
var storage = new DatabaseStorage();

// server/auth.ts
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import { Strategy as LinkedInStrategy } from "passport-linkedin-oauth2";
import * as jwt from "jsonwebtoken";
import crypto from "crypto";
import session2 from "express-session";
import { scrypt, randomBytes as randomBytes2, timingSafeEqual } from "crypto";
import { promisify } from "util";
var JWT_SECRET = process.env.JWT_SECRET || crypto.randomBytes(64).toString("hex");
var JWT_EXPIRES = "12h";
var JWT_OPTIONS = {
  algorithm: "HS512",
  expiresIn: JWT_EXPIRES,
  issuer: "atlas-auth",
  audience: "atlas-app",
  jwtid: crypto.randomBytes(16).toString("hex")
};
var scryptAsync2 = promisify(scrypt);
function setupAuth(app2) {
  const JWT_SECRET2 = process.env.JWT_SECRET || "your-secret-key";
  app2.use(session2({
    secret: process.env.SESSION_SECRET || crypto.randomBytes(32).toString("hex"),
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      httpOnly: true,
      sameSite: "strict",
      maxAge: 24 * 60 * 60 * 1e3,
      // 24 hours
      path: "/"
    },
    name: "__secure_session"
  }));
  app2.use(passport.initialize());
  app2.use(passport.session());
  passport.use(new LocalStrategy({ usernameField: "email" }, async (email, password, done) => {
    try {
      const user = await storage.getUserByEmail(email);
      if (!user) return done(null, false);
      const [hashedPassword, salt] = user.password.split(".");
      const hashedBuffer = await scryptAsync2(password, salt, 64);
      const storedHashedBuffer = Buffer.from(hashedPassword, "hex");
      if (!timingSafeEqual(hashedBuffer, storedHashedBuffer)) {
        return done(null, false);
      }
      return done(null, user);
    } catch (error) {
      return done(error);
    }
  }));
  if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
    passport.use(new GoogleStrategy({
      clientID: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      callbackURL: "/auth/google/callback"
    }, async (accessToken, refreshToken, profile, done) => {
      try {
        let user = await storage.getUserByEmail(profile.emails[0].value);
        if (!user) {
          user = await storage.createUser({
            email: profile.emails[0].value,
            name: profile.displayName,
            googleId: profile.id,
            role: "general"
          });
        }
        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }));
  }
  if (process.env.LINKEDIN_CLIENT_ID && process.env.LINKEDIN_CLIENT_SECRET) {
    passport.use(new LinkedInStrategy({
      clientID: process.env.LINKEDIN_CLIENT_ID,
      clientSecret: process.env.LINKEDIN_CLIENT_SECRET,
      callbackURL: "/auth/linkedin/callback",
      scope: ["r_emailaddress", "r_liteprofile"]
    }, async (accessToken, refreshToken, profile, done) => {
      try {
        let user = await storage.getUserByEmail(profile.emails[0].value);
        if (!user) {
          user = await storage.createUser({
            email: profile.emails[0].value,
            name: profile.displayName,
            linkedinId: profile.id,
            role: "general"
          });
        }
        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }));
  }
  passport.serializeUser((user, done) => {
    done(null, user.id);
  });
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error);
    }
  });
  app2.post("/api/auth/register", async (req, res) => {
    try {
      const { email, password, name, role } = req.body;
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "Email already registered" });
      }
      const salt = randomBytes2(16).toString("hex");
      const hashedBuffer = await scryptAsync2(password, salt, 64);
      const hashedPassword = `${hashedBuffer.toString("hex")}.${salt}`;
      const user = await storage.createUser({
        email,
        password: hashedPassword,
        name,
        role,
        verified: false
      });
      res.json({ message: "Registration successful" });
    } catch (error) {
      res.status(500).json({ message: "Registration failed" });
    }
  });
  app2.post("/api/auth/login", async (req, res, next) => {
    try {
      passport.authenticate("local", async (err, user, info) => {
        if (err) {
          return res.status(500).json({ error: err.message });
        }
        if (!user) {
          return res.status(401).json({ error: "Invalid credentials" });
        }
        req.logIn(user, (err2) => {
          if (err2) {
            return res.status(500).json({ error: err2.message });
          }
          const token = jwt.sign({ id: user.id }, JWT_SECRET2, JWT_OPTIONS);
          res.cookie("jwt", token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === "production",
            sameSite: "strict",
            maxAge: 24 * 60 * 60 * 1e3
          });
          const { password, ...safeUserData } = user;
          return res.status(200).json({
            success: true,
            user: safeUserData
          });
        });
      })(req, res, next);
    } catch (error) {
      console.error("Login error:", error);
      return res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/auth/google", passport.authenticate("google", { scope: ["profile", "email"] }));
  app2.get("/api/auth/google/callback", passport.authenticate("google"), (req, res) => {
    res.redirect("/dashboard");
  });
  app2.get("/api/auth/linkedin", passport.authenticate("linkedin"));
  app2.get("/api/auth/linkedin/callback", passport.authenticate("linkedin"), (req, res) => {
    res.redirect("/dashboard");
  });
  app2.post("/api/auth/logout", (req, res) => {
    req.logout(() => {
      res.clearCookie("jwt");
      res.json({ message: "Logged out" });
    });
  });
}

// server/routes.ts
import { z as z2 } from "zod";

// server/mailer.ts
import nodemailer from "nodemailer";
import { addMinutes } from "date-fns";
var templates = {
  bookingCancellation: (data) => `
    <h1>ATLAS Workspace Booking Cancellation</h1>
    <p>Hello ${data.userName},</p>
    <p>Your workspace booking has been cancelled.</p>
    <div style="margin: 20px 0;">
      <p><strong>Workspace:</strong> ${data.workspaceName}</p>
      <p><strong>Location:</strong> ${data.workspaceLocation}</p>
      <p><strong>Original Start:</strong> ${data.startTime}</p>
      <p><strong>Original End:</strong> ${data.endTime}</p>
      <p><strong>Booking ID:</strong> ${data.bookingId}</p>
    </div>
    <p>You can make a new booking from your ATLAS dashboard.</p>
  `,
  bookingModification: (data) => `
    <h1>ATLAS Workspace Booking Update</h1>
    <p>Hello ${data.userName},</p>
    <p>Your workspace booking has been modified!</p>
    <div style="margin: 20px 0;">
      <p><strong>Workspace:</strong> ${data.workspaceName}</p>
      <p><strong>Location:</strong> ${data.workspaceLocation}</p>
      <p><strong>New Start:</strong> ${data.startTime}</p>
      <p><strong>New End:</strong> ${data.endTime}</p>
      <p><strong>Booking ID:</strong> ${data.bookingId}</p>
    </div>
    <p>You can view the updated booking details in your ATLAS dashboard.</p>
  `,
  bookingCheckInReminder: (data) => `
    <h1>Time to Check In to Your Workspace</h1>
    <p>Hello ${data.userName},</p>
    <p>Your booking starts in 15 minutes!</p>
    <div style="margin: 20px 0;">
      <p><strong>Workspace:</strong> ${data.workspaceName}</p>
      <p><strong>Location:</strong> ${data.workspaceLocation}</p>
      <p><strong>Start:</strong> ${data.startTime}</p>
      <p><strong>End:</strong> ${data.endTime}</p>
    </div>
    <p>Please check in when you arrive at the workspace.</p>
  `,
  bookingConfirmation: (data) => `
    <h1>Your ATLAS Workspace Booking Confirmation</h1>
    <p>Hello ${data.userName},</p>
    <p>Your workspace booking has been confirmed!</p>
    <div style="margin: 20px 0;">
      <p><strong>Workspace:</strong> ${data.workspaceName}</p>
      <p><strong>Location:</strong> ${data.workspaceLocation}</p>
      <p><strong>Start:</strong> ${data.startTime}</p>
      <p><strong>End:</strong> ${data.endTime}</p>
      <p><strong>Booking ID:</strong> ${data.bookingId}</p>
    </div>
    <p>You can manage your booking from your ATLAS dashboard.</p>
  `,
  bookingReminder: (data) => `
    <h1>Upcoming Workspace Booking Reminder</h1>
    <p>Hello ${data.userName},</p>
    <p>This is a reminder about your upcoming workspace booking:</p>
    <div style="margin: 20px 0;">
      <p><strong>Workspace:</strong> ${data.workspaceName}</p>
      <p><strong>Location:</strong> ${data.workspaceLocation}</p>
      <p><strong>Start:</strong> ${data.startTime}</p>
      <p><strong>End:</strong> ${data.endTime}</p>
    </div>
    <p>We look forward to seeing you!</p>
  `
};
var isDev = process.env.NODE_ENV === "development";
var transporter = isDev ? null : nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || "587"),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
});
async function sendEmail(to, subject, html) {
  if (isDev) {
    console.log(`[EMAIL SERVICE] To: ${to}
Subject: ${subject}
Body:
${html}`);
    return;
  }
  return transporter?.sendMail({
    from: process.env.SMTP_FROM || "noreply@atlas-app.com",
    to,
    subject,
    html
  });
}
async function sendBookingConfirmation(email, data) {
  await sendEmail(
    email,
    "Your ATLAS Workspace Booking Confirmation",
    templates.bookingConfirmation(data)
  );
  const startTime = new Date(data.startTime);
  const reminderTime = addMinutes(startTime, -24 * 60);
  if (reminderTime > /* @__PURE__ */ new Date()) {
    setTimeout(async () => {
      await sendEmail(
        email,
        "Reminder: Upcoming Workspace Booking",
        templates.bookingReminder(data)
      );
    }, reminderTime.getTime() - Date.now());
  }
}

// server/openai.ts
import OpenAI from "openai";
var openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
async function callOpenAIAPI(options) {
  try {
    console.log("Calling OpenAI API with options:", JSON.stringify({
      ...options,
      // Don't log full message content for privacy
      messages: options.messages.map((m) => ({ role: m.role, content_length: m.content.length }))
    }));
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: options.messages,
      max_tokens: options.max_tokens || 300,
      temperature: options.temperature || 0.7,
      top_p: options.top_p || 1,
      frequency_penalty: options.frequency_penalty || 0,
      presence_penalty: options.presence_penalty || 0
    });
    console.log("OpenAI API success - response:", response.choices.length + " choices received");
    return {
      choices: response.choices.map((choice) => ({
        message: {
          role: choice.message.role,
          content: choice.message.content
        },
        finish_reason: choice.finish_reason
      })),
      id: response.id,
      model: response.model,
      object: "chat.completion",
      usage: response.usage
    };
  } catch (error) {
    console.error("Error calling OpenAI API:", error);
    throw error;
  }
}
async function handleChatRequest(req, res) {
  try {
    const { messages } = req.body;
    if (!messages || !Array.isArray(messages)) {
      return res.status(400).json({ error: "Invalid messages format" });
    }
    const formattedMessages = [
      {
        role: "system",
        content: "You are ATLAS Assistant, a helpful AI for the ATLAS workspace booking application. Be concise, friendly, and focus on helping users with workspace bookings, account management, and general workspace questions. Limit responses to 3-4 sentences max."
      },
      ...messages
    ];
    try {
      const response = await callOpenAIAPI({
        messages: formattedMessages,
        temperature: 0.7,
        max_tokens: 300
      });
      return res.json(response);
    } catch (apiError) {
      console.error("API call failed, using fallback response:", apiError);
      const fallbackResponse = {
        choices: [
          {
            message: {
              role: "assistant",
              content: `I apologize, but I'm having trouble connecting to my knowledge base at the moment. For ATLAS workspace bookings, you can use the calendar on the workspaces page to check availability and make reservations. If you have any other questions, please try again later or contact support.`
            },
            finish_reason: "stop"
          }
        ],
        id: "fallback-response",
        model: "fallback-model",
        object: "chat.completion",
        usage: {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
      return res.json(fallbackResponse);
    }
  } catch (error) {
    console.error("Chat request error:", error);
    return res.status(500).json({ error: "Failed to get chat response" });
  }
}

// server/routes.ts
async function registerRoutes(app2) {
  setupAuth(app2);
  app2.get("/api/workspaces", async (req, res) => {
    try {
      const workspaces2 = await storage.getWorkspaces();
      res.json(workspaces2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch workspaces" });
    }
  });
  app2.get("/api/workspaces/:id", async (req, res) => {
    try {
      const workspace = await storage.getWorkspace(parseInt(req.params.id));
      if (!workspace) {
        return res.status(404).json({ message: "Workspace not found" });
      }
      res.json(workspace);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch workspace" });
    }
  });
  app2.post("/api/workspaces", async (req, res) => {
    try {
      if (!req.isAuthenticated() || req.user.role !== "admin") {
        return res.status(403).json({ message: "Unauthorized" });
      }
      const validatedData = insertWorkspaceSchema.parse(req.body);
      const workspace = await storage.createWorkspace(validatedData);
      res.status(201).json(workspace);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid workspace data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create workspace" });
    }
  });
  app2.get("/api/bookings", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      let bookings2;
      if (req.user.role === "admin") {
        bookings2 = await storage.getAllBookings();
      } else {
        bookings2 = await storage.getUserBookings(req.user.id);
      }
      const bookingsWithWorkspaces = await Promise.all(
        bookings2.map(async (booking) => {
          const workspace = await storage.getWorkspace(booking.workspaceId);
          return { ...booking, workspace };
        })
      );
      res.json(bookingsWithWorkspaces);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch bookings" });
    }
  });
  app2.post("/api/bookings", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const validatedData = insertBookingSchema.parse({
        ...req.body,
        userId: req.user.id
      });
      const isAvailable = await storage.checkWorkspaceAvailability(
        validatedData.workspaceId,
        new Date(validatedData.startTime),
        new Date(validatedData.endTime)
      );
      if (!isAvailable) {
        return res.status(409).json({ message: "Workspace is not available for the selected time" });
      }
      const booking = await storage.createBooking(validatedData);
      const workspace = await storage.getWorkspace(booking.workspaceId);
      await storage.createNotification({
        userId: req.user.id,
        title: "Booking Confirmed",
        message: `Your booking for ${workspace?.name} has been confirmed`,
        type: "booking_confirmation",
        relatedBookingId: booking.id,
        isRead: false
      });
      await storage.createNotification({
        userId: req.user.id,
        title: "Booking Confirmed",
        message: `Your booking for ${workspace?.name} has been confirmed`,
        type: "success",
        read: false
      });
      if (workspace && req.user.email) {
        sendBookingConfirmation(req.user.email, {
          userName: req.user.companyName,
          workspaceName: workspace.name,
          workspaceLocation: workspace.location,
          startTime: new Date(booking.startTime).toLocaleString(),
          endTime: new Date(booking.endTime).toLocaleString(),
          bookingId: booking.id.toString()
        });
      }
      res.status(201).json({ ...booking, workspace });
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid booking data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create booking" });
    }
  });
  app2.patch("/api/bookings/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const bookingId = parseInt(req.params.id);
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      if (booking.userId !== req.user.id && req.user.role !== "admin") {
        return res.status(403).json({ message: "Unauthorized" });
      }
      const updates = {};
      if (req.body.status) {
        updates.status = req.body.status;
      }
      if (req.body.startTime && req.body.endTime) {
        const isAvailable = await storage.checkWorkspaceAvailability(
          booking.workspaceId,
          new Date(req.body.startTime),
          new Date(req.body.endTime),
          bookingId
          // Exclude current booking from check
        );
        if (!isAvailable) {
          return res.status(409).json({ message: "Workspace is not available for the selected time" });
        }
        updates.startTime = new Date(req.body.startTime);
        updates.endTime = new Date(req.body.endTime);
      }
      const updatedBooking = await storage.updateBooking(bookingId, updates);
      const workspace = await storage.getWorkspace(updatedBooking.workspaceId);
      await storage.createNotification({
        userId: updatedBooking.userId,
        title: updates.status === "cancelled" ? "Booking Cancelled" : "Booking Updated",
        message: updates.status === "cancelled" ? `Your booking for ${workspace?.name} has been cancelled` : `Your booking for ${workspace?.name} has been updated`,
        type: updates.status === "cancelled" ? "booking_cancellation" : "booking_update",
        relatedBookingId: bookingId,
        isRead: false
      });
      res.json(updatedBooking);
    } catch (error) {
      res.status(500).json({ message: "Failed to update booking" });
    }
  });
  app2.delete("/api/bookings/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const bookingId = parseInt(req.params.id);
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      if (booking.userId !== req.user.id && req.user.role !== "admin") {
        return res.status(403).json({ message: "Unauthorized" });
      }
      await storage.deleteBooking(bookingId);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: "Failed to delete booking" });
    }
  });
  app2.get("/api/analytics", async (req, res) => {
    try {
      if (!req.isAuthenticated() || req.user.role !== "admin") {
        return res.status(403).json({ message: "Unauthorized" });
      }
      const stats = await storage.getAnalytics();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/notifications", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const { limit, unreadOnly } = req.query;
      const options = {};
      if (limit) {
        options.limit = parseInt(limit);
      }
      if (unreadOnly === "true") {
        options.unreadOnly = true;
      }
      const notifications2 = await storage.getUserNotifications(userId, options);
      res.json(notifications2);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });
  app2.get("/api/notifications/count", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const count2 = await storage.getUnreadNotificationsCount(userId);
      res.json({ count: count2 });
    } catch (error) {
      console.error("Error counting notifications:", error);
      res.status(500).json({ message: "Failed to count notifications" });
    }
  });
  app2.post("/api/notifications", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const validatedData = insertNotificationSchema.parse(req.body);
      if (validatedData.userId !== req.user.id && req.user.role !== "admin") {
        return res.status(403).json({ message: "You can only create notifications for your own account" });
      }
      const notification = await storage.createNotification(validatedData);
      res.status(201).json(notification);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid notification data", errors: error.errors });
      }
      console.error("Error creating notification:", error);
      res.status(500).json({ message: "Failed to create notification" });
    }
  });
  app2.patch("/api/notifications/:id/read", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const notificationId = parseInt(req.params.id);
      const userId = req.user.id;
      const notification = await storage.getNotification(notificationId);
      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }
      if (notification.userId !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Forbidden" });
      }
      const updatedNotification = await storage.markNotificationAsRead(notificationId);
      res.json(updatedNotification);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to update notification" });
    }
  });
  app2.patch("/api/notifications/mark-all-read", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const updatedCount = await storage.markAllNotificationsAsRead(userId);
      res.json({ message: `Marked ${updatedCount} notifications as read`, count: updatedCount });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to update notifications" });
    }
  });
  app2.delete("/api/notifications/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const notificationId = parseInt(req.params.id);
      const userId = req.user.id;
      const notification = await storage.getNotification(notificationId);
      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }
      if (notification.userId !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Forbidden" });
      }
      await storage.deleteNotification(notificationId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).json({ message: "Failed to delete notification" });
    }
  });
  app2.delete("/api/notifications", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const { readOnly } = req.query;
      let deletedCount;
      if (readOnly === "true") {
        deletedCount = await storage.deleteReadNotifications(userId);
      } else {
        deletedCount = await storage.deleteAllUserNotifications(userId);
      }
      res.status(200).json({
        message: `Successfully deleted ${deletedCount} notifications`,
        count: deletedCount
      });
    } catch (error) {
      console.error("Error deleting all notifications:", error);
      res.status(500).json({ message: "Failed to delete notifications" });
    }
  });
  app2.post("/api/chat", async (req, res) => {
    try {
      if (!process.env.OPENAI_API_KEY) {
        return res.status(503).json({
          error: "AI service unavailable, please configure OpenAI API key",
          choices: [{
            message: {
              role: "assistant",
              content: "Sorry, the AI assistant is currently unavailable. Please try again later."
            }
          }]
        });
      }
      return await handleChatRequest(req, res);
    } catch (error) {
      console.error("Chat endpoint error:", error);
      return res.status(500).json({ error: "Failed to process chat request" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();